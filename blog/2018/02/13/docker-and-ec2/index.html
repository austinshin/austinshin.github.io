
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>docker and ec2 - Austin Shin</title>
	<meta name="author" content="Austin Shin">

	
	<meta name="description" content="Docker and Ec2 A Docker And EC2 Instance Guide - This is a bare bones guide to setting up a project on an EC2 instance Things this guide will cover &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="Austin Shin" type="application/atom+xml">
	
	<link rel="canonical" href="http://austinshin.github.io/blog/2018/02/13/docker-and-ec2/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		$(function(){
			$('.profilepic').append("<img src='http://www.gravatar.com/avatar/" + MD5("shinaustin@gmail.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
		});
	</script>
	
</div>

<nav id="main-nav"><ul class="main">
    <li><a href="/"><h1>Austin Shin</h1></a></li>
    <li><a href="/blog/">Blog</a></li>
    <li><a href="/about">Achievements</a></li>
    <li><a href="/blog/archives">Archives</a></li>
    <li><a href="/blog/categories/sideproject">Side Project</a></li>
    <li><a href="https://github.com/austinshin">Github</a></li>
    <li><a href="https://instagram.com/link115">Instagram</a></li>
    <li><a href="https://twitter.com/link115_">Twitter</a></li>
    <li><a href="https://www.youtube.com/playlist?list=PLfdaAogiAw-igfBt_uIBuO3uewbsPENzw">Playlist</a></li>
  </ul>

</nav>
<nav id="sub-nav">
	<div class="social">
		
			<a class="email" href="mailto:shinaustin@gmail.com" title="Email">Email</a>
		
		
		
		
			<a class="twitter" href="http://twitter.com/link115_" title="Twitter">Twitter</a>
		
		
			<a class="github" href="https://github.com/austinshin" title="GitHub">GitHub</a>
		
		
		
		
		
		
		
		
		
		
    	
    	
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner"><article class="post" itemscope itemtype="http://schema.org/BlogPosting">
	<h1 class="title" itemprop="name">Docker and Ec2</h1>
	<div class="entry-content" itemprop="articleBody"><h1>A Docker And EC2 Instance Guide</h1>

<p>-</p>

<p><strong>This is a bare bones guide to setting up a project on an EC2 instance</strong></p>

<p>Things this guide will cover and hopefully answer:</p>

<ol>
<li>What is docker?</li>
<li>What is an EC2 Instance?</li>
<li>How do I tie them together with my app that I am developing locally?</li>
<li>How do I set it up?</li>
</ol>


<p>-</p>

<!--more-->


<p><strong>Disclaimer:</strong>
This is a naive method. It does not use ECS, load balancing, clusters all that stuff. You can look that up (and its very confusing tutorials which I thoroughly browsed) if you wish.</p>

<p>If you have a two databases and one node app (i.e redis, mongodb, nodejs files) you should end up with 3 ec2 instances. (1 minimum dockerized container or 3 depending on how you do it).</p>

<p>There is an even more naive way to do it which is to just use docker-compose on all 3 and put them in one ec2-instance (if you got docker-compose to work on your local machine you are basically doing the same thing on your ec2 instance).</p>

<p><strong>I suggest skimming through the guide to get a good understanding of how this works before blindly following it (although I believe I covered most of the essentials). YOU MIGHT HAVE TO GOOGLE SOME STUFF in addition.</strong></p>

<p>-</p>

<h1>Create an EC2 Instance.</h1>

<ol>
<li>Follow this guide
<a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/get-set-up-for-amazon-ec2.html">https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/get-set-up-for-amazon-ec2.html</a></li>
<li>Sign up for AWS (make an account/pw), create an IAM user, create a key pair.</li>
<li><strong>Save your key pair to your local machine. You will use it. (It should be a .pem file) Mine will be called app.pem for reference.</strong></li>
<li>MAKE SURE YOU ARE IN THE <strong>CORRECT REGION</strong> YOU WANT TO BE IN</li>
<li>(select in top-right us-west-1 N. California).
<img src="https://puu.sh/znR7s/f6c593d6fd.png" alt="ss" /></li>
<li><p>You do not have to create a VPC or security group.</p></li>
<li><p>In you AWS console, click the top left Services button and then EC2 (make sure correct region always)</p></li>
<li>Click Launch Instance.</li>
<li>Select type of machine image you want to launch. I suggest one of these.
They require different commands depending on the one you choose.

<ul>
<li>Amazon Linux AMI 2017.09.1 (HVM), SSD Volume Type</li>
<li>Ubuntu Server 16.04 LTS (HVM), SSD Volume Type - ami-07585467</li>
</ul>
</li>
<li>Select type of instance you want.

<ul>
<li>t2.micro is free tier eligible</li>
<li>Other ones you have to pay more depending on how long they are running for.</li>
<li>Bigger ones give more space or are &lsquo;stronger&rsquo; cpus.</li>
</ul>
</li>
<li>Select default for everything for simplicity sake
(you can specifiy and customize as you understand/research more).</li>
<li>Step 4 (Add storage), 5 (Add tags) leave default.</li>
<li><p>Step 6 - Configure security group</p>

<ul>
<li>Make sure you have something like this for your security group.
<img src="https://puu.sh/znQGT/affbd06e61.png" alt="ss" /></li>
<li>This is super important because you need to have the inbound port 22 allowed
so you can access it from the outside world (which is what SSH uses).</li>
<li>Another example: You want to access your service from the outside world on
port 80. So what you would do is add another inbound rule allowing port 80
of a specific ip (or anywhere).</li>
<li>The figure below allows access on port 80, 22, 6379, 7474, 3000, 7687 on anywhere.
<img src="https://puu.sh/znQZ2/8851b026d4.png" alt="ss" /></li>
<li>Add the ports you need depending on the database your port exposes to.</li>
</ul>
</li>
<li><p>Review and Launch and wait for it to set up.</p></li>
<li>You should see something like this now in Services -> Instances.
<img src="https://puu.sh/znRam/44bfb0821a.png" alt="ss" /></li>
<li>Click it. At the bottom you should see a public IPv4. This is the IP you can access your instance from.</li>
<li>We now need to ssh into it.</li>
</ol>


<p>On your terminal (omit the $ from all your commands you c/p).</p>

<p>Find your pem file (mine is app.pem) and is located on desktop. You can move it to your
~/.ssh folder if you wish.
Do 1 of these.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>example: $ chmod 400 &lt;PATH TO pem file&gt;
</span><span class='line'>
</span><span class='line'>$ chmod 400 ~/desktop/app.pem        &lt;- (if it located in desktop)
</span><span class='line'>$ chmod 400 ~/.ssh/app.pem           &lt;- (if it is located in .ssh)</span></code></pre></td></tr></table></div></figure>


<p>Now we ssh in using this template</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>example: $ ssh -i &lt;PATH TO pem file&gt; &lt;type of machine image&gt;@&lt;public ip of YOUR ec2 instance&gt;
</span><span class='line'>
</span><span class='line'>$ ssh -i ~/desktop/app.pem ec2-user@57.213.217.136     &lt;- use this if you created a linux machine image from step 4.
</span><span class='line'>$ ssh -i ~/desktop/app.pem ubuntu@57.213.217.136       &lt;- use this if you created an ubuntu machine image from step 4.
</span></code></pre></td></tr></table></div></figure>


<h4>Success your ec2 instance is now created!</h4>

<h2>This part below is optional. Only do this if you DON&rsquo;T want to use docker. Skip to docker otherwise.</h2>

<h3>Installing a Database/application to your ec2 instance.</h3>

<p>Now you should have access to your ec2 instance. You can run commands on it and do whatever you wish. The best way to think about your ec2-instance is that it is now your new &lsquo;local computer&rsquo;. You can install any type of database you wish i.e. mongodb, redis, neo4j, cassandra, postgres, mysql, etc. How do I do this?</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Google this: "How to install &lt; DB NAME &gt; on &lt; MachineImageUsedType &gt; EC2 Instance"</span></code></pre></td></tr></table></div></figure>


<p>i.e. &ldquo;How to install redis on linux ec2 instance&rdquo; links me to this <a href="https://medium.com/@andrewcbass/install-redis-v3-2-on-aws-ec2-instance-93259d40a3ce">article</a>.</p>

<p>Follow the steps! Some of the links will lead you to the official manual to set you up.
Each database has its own specific quirk to installing it on Ubuntu or Linux just like own OSX or Windows. You have to figure that part out.</p>

<p>Note: installation of certain databases (like redis) is super simple.</p>

<p>Installation of certain databases (like cassandra) is really annoying because you have to configure yml files and whatnot. Look at the section below if you want to skip this pain.</p>

<p><strong>Assuming you decided to not use docker and you installed your specific database.</strong></p>

<p>Ideally when you are sshed into your EC2 Instance you should be able to run something like if you have your db properly installed.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ redis-cli
</span><span class='line'>$ cypher-shell
</span><span class='line'>$ MYSQL -u root
</span><span class='line'>$ cqlsh</span></code></pre></td></tr></table></div></figure>


<p><strong>If you properly installed it on your EC2 instance, move onto the exposing port to real world</strong></p>

<p>Hopefully it worked!</p>

<p>Final note for this section: You can also deploy your regular applications this way too! Say your MVP project. You could git clone your files from the ec2 instance, spin it up, install a package that has node run detached, expose port 3000 (or whatever port you exposed in express), and you now have access to that app from the real world!</p>

<p>-</p>

<h1>Docker</h1>

<p>There is an issue with installing databases and applications on an EC2 instance.
For example, installing cassandra on OSX is a pain in the ass. You have to make sure you have the specific Java version (8 with a specific tag)&hellip; You have to install all these different dependencies. Some of these dependencies change according to the machine you have. Imagine trying to install it on some new interface (Linux,Ubuntu) you&rsquo;ve never dealt with.</p>

<p><strong>I wish I could do something like a npm install cassandra on this EC2 instance and magically make it for me.</strong></p>

<p><strong>Here is where docker comes in.</strong></p>

<p>You can skip all the previous installation steps in the section above and trying to figure out how to install and get the correct packages on your linux/ubuntu instance and just do this.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1. Install docker
</span><span class='line'>2. Pull the docker database image
</span><span class='line'>3. Run the docker image (creating a new container) on a specific port
</span><span class='line'>4. Expose the port via the inbound security group
</span><span class='line'>5. You're done!</span></code></pre></td></tr></table></div></figure>


<p>Docker is an OS virtualization within a computer which provides a layer of abstraction. This means all of the apps you want to build will always build equally across different types of machines. Imagine if you were building an application on OSX, but randomly decided to change operating systems to Windows. Instead of reinstalling everything on Windows, you can just install docker, create a docker image of your app, pull it to your windows, then continue to work off that. It enables <strong>consistency across environments.</strong></p>

<p>-</p>

<h1>Using Docker</h1>

<h3>If you are using a Linux machine image from step 4.</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>YourTerminal-$ ssh -i ~/desktop/app.pem ec2-user@57.213.217.136
</span><span class='line'>
</span><span class='line'>You should be sshed into your ec2-instance now (type yes).
</span><span class='line'>
</span><span class='line'>ec2-linux-$ sudo yum update                           &lt;- updates linux
</span><span class='line'>ec2-linux-$ sudo yum install -y docker                &lt;- installs docker
</span><span class='line'>ec2-linux-$ sudo service docker start                 &lt;- starts docker
</span><span class='line'>ec2-linux-$ sudo usermod -a -G docker ec2-user        &lt;- no longer need sudo for docker commands
</span><span class='line'>ec2-linux-$ docker info                               &lt;- docker info</span></code></pre></td></tr></table></div></figure>


<h3>If you are using an Ubuntu machine image from step 4.</h3>

<p>Commands are slightly different.</p>

<p>Referenced from <a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-16-04">https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-16-04</a></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>YourTerminal-$ ssh -i ~/desktop/app.pem ubuntu@57.213.217.136
</span><span class='line'>ec2-ubuntu-$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
</span><span class='line'>ec2-ubuntu-$ sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
</span><span class='line'>ec2-ubuntu-$ sudo apt-get update
</span><span class='line'>ec2-ubuntu-$ apt-cache policy docker-ce
</span><span class='line'>ec2-ubuntu-$ sudo apt-get install -y docker-ce
</span><span class='line'>ec2-ubuntu-$ sudo systemctl status docker</span></code></pre></td></tr></table></div></figure>


<p>Great. We now have docker installed on our ec2 instance. What&rsquo;s next? It&rsquo;s very simple. All we have to do is figure out what image from dockerhub to pull down depending on our database.</p>

<p>Go here -> <a href="https://hub.docker.com/explore/">dockerhub</a></p>

<p>You can see all types of pre built official images like node, redis, mongo, mysql, etc.</p>

<p>Let&rsquo;s say we want to spin up a redis container.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Make sure docker is running.
</span><span class='line'>ec2-instance-$ docker run --name new-redis-instance -d -p 6379:6379 redis
</span></code></pre></td></tr></table></div></figure>


<p>If you have enough memory on your ec2 instance and it can support the database, it should work.</p>

<p>The run command looks for an image name and pulls from dockerhub if one is not stored locally. It uses the image to spin up a container of the application you specified (the image).</p>

<p>The -d flag creates the container in detached mode. Meaning you can just exit out of your ec2 instance and it will still be running. The first port is the one it exposes to the outside, and the second port is the one for the inside world.</p>

<p>The &ndash;name flag is to specify the name.</p>

<p>The last &lsquo;redis&rsquo; is just the image name. So if I wanted to use the mongo image I&rsquo;d use &lsquo;mongo&rsquo; instead. If I wanted to specify a specific version, I could add a tag like so.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ec2-instance-$ docker run --name new-redis-instance -d -p 6379:6379 redis:alpine</span></code></pre></td></tr></table></div></figure>


<p>Useful docker commands</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ docker ps -a                       &lt;- shows all containers running/stopped
</span><span class='line'>$ docker stop 'container name/id'       &lt;- specify the container you wish to stop.
</span><span class='line'>$ docker rm 'container name/id'         &lt;- remove the container you wish (this destroys data unless you specified a volume)
</span><span class='line'>$ docker images                      &lt;- shows all images you've downloaded locally (cached)
</span><span class='line'>$ docker rmi 'image name/id'         &lt;- deletes the image
</span><span class='line'>$ docker network ls                  &lt;- shows all docker networks
</span><span class='line'>$ docker inspect 'specific network i.e bridge'    &lt;- shows all docker containers on that network (useful for docker-compose)
</span><span class='line'>$ docker exec -it 'container name' sh  &lt;- ssh into docker container shell.
</span></code></pre></td></tr></table></div></figure>


<p>To make sure it is working&hellip; do this next! If your container is immediately crashing it might be a memory issue (your service isn&rsquo;t capable enough to handle it). But for mongo, redis, a micro should be enough (until you upload millions of data).</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ec2-instance-$ docker ps -a     &lt;- make sure your docker container is working (for the db!)
</span><span class='line'>ec2-instance-$ docker exec -it 'container name' sh        &lt;- sshs you into the shell.</span></code></pre></td></tr></table></div></figure>


<p>You should now be in your docker container and be able to browse the contents. Essentially you are now inside of a computer inside of a computer&hellip; pretty cool!
Try running the cli for your specific database. So, if you created a redis db you should be able to do:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker-container-$ redis-cli</span></code></pre></td></tr></table></div></figure>


<p>And it should work. This means your db inside your docker is up and running and if you ran the specific port, it is exposing it outside to ec2 (via 6379) when you did docker run -p 6379:6379.</p>

<p>The last step is to now expose your 6379 port to the outside world. In otherwords, have other services be able to talk to it. Follow the steps in &ldquo;Exposing port to the real world for EC2 Instance&rdquo;</p>

<p>-</p>

<h1>Exposing port to the real world for EC2 Instances.</h1>

<p>These next few steps apply to whether you are using docker or no docker (only for AWS).
The next step is to make sure you have the port you can access your db to expose. So if you use redis, the default port it exposes the database to something like 6379 i.e localhost:6379.</p>

<p>So for example if I created an EC2 Instance and I wanted to access the redis db on the ec2 instance from locally (your computer).</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>I should be able to access my EC2 Instance from Public ip: 54.241.150.234:6379 right?</span></code></pre></td></tr></table></div></figure>


<p><img src="https://puu.sh/znVzL/d79d0c5f0c.png" alt="ss" />
Wrong. Remember the security group port thing I was talking about all the way back in step 8 when creating the EC2 Instance. Well now is where you actually specify which port to expose to the real world (to machines like our local ones).</p>

<ol>
<li>Go to Services -> EC2 -> Instances.</li>
<li>You should see the screen like the picture above.</li>
<li>Click the security groups link.
<img src="https://puu.sh/znVSA/614f86c808.png" alt="ss" /></li>
<li>Scroll down to the bottom and click the inbound tab -> Edit.</li>
<li>So if you want to expose 6379 to the real world, you need to add the port number in, and choose the source. The source is who you want to allow to access it. If you want everyone in the world to access your database, just click anywhere. (This is bad practice!) You only really want to have your database be accessed by the service that interacts with it. In other words, like an EC2 Instance that has the node server&hellip; or perhaps your local machine. Once you click save, you should now be able to send requests to PUBLIC IP:DBPORTNUMBER via postman, curls, insomnia. (You&rsquo;d change the localhost to EC2 instance IP/port on your NodeJS files).</li>
</ol>


<p>You should now be able to connect from anywhere if you specify the correct ip/port from any client! (If it doesn&rsquo;t it&rsquo;s because you need to edit the yml files for certain databases like cassandra/neo4j)&hellip; but for redis/mongo it should be straightforward&hellip;</p>

<p>Repeat the steps above for all the databases you need to create if you want to &lsquo;split them apart into different instances&rsquo;</p>

<p>-</p>

<h1>Okay I got my database deployed, but how do I deploy my app?</h1>

<p>The best way to do is to create a docker image of your app (your node files).</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0. Install docker on your computer.
</span><span class='line'>1. Go to your root project directory
</span><span class='line'>2. $ touch dockerfile
</span><span class='line'>3. copy this into the docker file
</span><span class='line'>    FROM node:carbon
</span><span class='line'>
</span><span class='line'>    RUN mkdir -p /src/app
</span><span class='line'>
</span><span class='line'>    WORKDIR /src/app
</span><span class='line'>
</span><span class='line'>    COPY . /src/app
</span><span class='line'>
</span><span class='line'>    RUN npm install
</span><span class='line'>
</span><span class='line'>    EXPOSE 3000
</span><span class='line'>
</span><span class='line'>    CMD [ "npm", "start" ]
</span><span class='line'>4. $ docker build -t nameofproject/tag .       &lt;- make sure you include the . it builds everything inside the current directory using the dockerfile into an image.
</span><span class='line'>5. $ docker images                             &lt;- you should see your image now!
</span><span class='line'>6. Follow this guide for pushing your image to your dockerhub
</span><span class='line'>   https://docs.docker.com/docker-cloud/builds/push-images/
</span><span class='line'>7. Create a new EC2 Instance (do the steps above)
</span><span class='line'>8. Install docker on the ec2 instance
</span><span class='line'>9. Pull your docker image of your app
</span><span class='line'>10. Run the docker container and your app should now be running.
</span><span class='line'>11. Lastly, add the security group to expose whatever port you are using...
</span><span class='line'>12. Your app is now available as a service to other services by accessing the public IP!
</span><span class='line'>    This means if you have an endpoint to "/api/getUsers",  you can have a service
</span><span class='line'>    do fetch('ec2-publicip:3000/api/getUsers'). In turn, your service will call your db
</span><span class='line'>    which is set up to a different ec2 instance (you set up earlier) and if you have data,
</span><span class='line'>    return results!</span></code></pre></td></tr></table></div></figure>


<p>-</p>

<h1>Adding data to my database on docker/ec2</h1>

<p>How do I upload my data if I have .csv or .json files locally?
You can ssh them into your instances/containers.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>local-machine-$ scp -i ~/pathtomypem -r machine-image@public-ipv4:~/dst src
</span><span class='line'>ex: local-machine-$ scp -i ~/.ssh/app.pem -r ec2-user@54.159.147.19:~/. ~/.neo4j/data/import
</span><span class='line'>
</span><span class='line'>then ssh into your ec2-instance
</span><span class='line'>
</span><span class='line'>ex: local-machine-$ ssh -i ~/.ssh/app.pem ec2-user@54.159.147.19
</span><span class='line'>
</span><span class='line'>your data will be wherever you specified the dst path to.
</span><span class='line'>
</span><span class='line'>ec2-instance-$ sudo docker cp src/files image:/dist
</span><span class='line'>ex: ec2-instance-$ sudo docker cp Desktop/file da9230faeb38:/
</span><span class='line'>
</span><span class='line'>Then import your data via cli or however you did it
</span></code></pre></td></tr></table></div></figure>


<p>-</p>

<h1>Conclusion</h1>

<p>There&rsquo;s all this stuff about docker-compose I&rsquo;ve been reading about and ECS, and load balancing, and auto balancing, and clusters, and task definitions, and whatnot. These are all correct things to do and things to add on if you want to make your application &lsquo;dynamic&rsquo;.</p>

<p>A cluster is a managing system to bundle certain ec2 instances together. You can specify which specific task each service should run. Each specific task would equate to a docker container. Each service would equate to a docker image. This means you can have multiple databases running (multiple tasks) of the same database (one service). If you think about this means you can split up the work your databases do.</p>

<p>If you had two databases, you can have one specifically write, and the other read. You could create a queue that splits up the work each database does. If you have many concurrent users, you don&rsquo;t want them to read from the same database. You can create copies of your database and have certain users go to certain databases to get their info.</p>

<p>The even cooler part of AWS is the load balancing/auto balancing part. Say your ec2 instance dies, you can&rsquo;t have that happen. AWS will just create a new one based on the minimum tasks that need to be running (so no downtime).</p>

<p>The flaw of the tutorial above is that you are hardcoding a specific ec2-instance into your exxpress server. In the event, it crashes&hellip; well a new ip is assigned when you create an ec2-instance. There are ways to handle that (elastic ip addresses) or creating subnets via VPC, but I didn&rsquo;t get a chance to explore it too deeply. For the sake of our project, I don&rsquo;t think people will be creating more than 1-3 ec2 instances as well (for financial purposes).</p>

<p>This is a very <strong>NAIVE</strong> but hopefully a good way to shed light on how EC2 and docker work.</p>

<p>LASTLY, I want to say that you can be even more naive!</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1. Push up your app image to dockerhub
</span><span class='line'>2. Create a docker-compose file of all your services.
</span><span class='line'>3. Make an EC2 Instance
</span><span class='line'>4. Install docker
</span><span class='line'>5. SSH/git clone that file into your EC2 Instance
</span><span class='line'>6. Run docker-compose file.
</span><span class='line'>
</span><span class='line'>Now ALL your containers are running on one instance (which resource-wise, very inefficient).
</span></code></pre></td></tr></table></div></figure>



</div>

</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
	
	<a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
	
	
	<a class="addthis_button_tweet"></a>
	
	
	<a class="addthis_button_google_plusone" g:plusone:size="false"></a>
	
	<a class="addthis_counter addthis_pill_style"></a>
	</div>
  <script type="text/javascript" src="http://s7.addthis.com/js/250/addthis_widget.js#pubid="></script>
</div>



</div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2018

    Austin Shin


Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
		</div>
	</div>
	



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>




</body>
</html>

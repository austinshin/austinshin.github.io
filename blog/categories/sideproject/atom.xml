<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: sideproject | Austin Shin]]></title>
  <link href="http://austinshin.github.io/blog/categories/sideproject/atom.xml" rel="self"/>
  <link href="http://austinshin.github.io/"/>
  <updated>2018-02-26T13:46:48-08:00</updated>
  <id>http://austinshin.github.io/</id>
  <author>
    <name><![CDATA[Austin Shin]]></name>
    <email><![CDATA[shinaustin@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[tic-tac-toe cli]]></title>
    <link href="http://austinshin.github.io/blog/2018/02/22/tic-tac-toe/"/>
    <updated>2018-02-22T14:16:49-08:00</updated>
    <id>http://austinshin.github.io/blog/2018/02/22/tic-tac-toe</id>
    <content type="html"><![CDATA[<p>Created a tic-tac-toe command line game to practice coding under time constraints and practice using node&rsquo;s readline.</p>

<p>Find it here:</p>

<p><a href="https://github.com/austinshin/tictactoe-cli">tictactoe</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[blackjack]]></title>
    <link href="http://austinshin.github.io/blog/2018/02/22/blackjack/"/>
    <updated>2018-02-22T14:16:41-08:00</updated>
    <id>http://austinshin.github.io/blog/2018/02/22/blackjack</id>
    <content type="html"><![CDATA[<p>Created a blackjack game run through command line to practice quick programming and object-oriented programming. First experience with node&rsquo;s readline.</p>

<p>Find it here:</p>

<p><a href="https://github.com/austinshin/blackjack-cli">blackjack</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[backazon - a recommendation service ]]></title>
    <link href="http://austinshin.github.io/blog/2018/01/24/amazon/"/>
    <updated>2018-01-24T16:42:45-08:00</updated>
    <id>http://austinshin.github.io/blog/2018/01/24/amazon</id>
    <content type="html"><![CDATA[<p>Project summary:
I worked on a project with a team building a backend API services system dealing with millions of data. It was to answer a business question: “Which recommendation algorithm collaboration or content-filtered, generates more sales/revenue in Amazon?”</p>

<!-- more -->


<p>Collaborative filtering is based on user-user comparison from previously viewed/bought/favorited items.</p>

<p>Content filtering is based on item-item comparison from past browsing history</p>

<p>A lot of initial planning was done as it was going to be a service integrated with 4 other services.</p>

<h2>First major decision was to decide which database to use.</h2>

<p>MYSQL vs NOSQL.</p>

<p>Should I use Postgres or Mongo or MySQL?</p>

<p>Should I use a giant big table or should I use many different entries?</p>

<p>Should I use graphQL as a querying system?</p>

<p>All of these interesting databases I was reading about sounded great until I found one: neo4j.</p>

<p>I decided to use NEO4j as a database because it was a graph database. The service I was building was only really interested in the relationships between a user and a product. Therefore, a database system that focused on relationships (a graph) which can create ‘nodes’ as users/products and ‘edges’ relationships made the most sense. This meant data modeling was clearer, data querying was more efficient vs doing multiple ‘joins’ on a table trying to create a relationship, and the database abstracted away all the complicated things. Likewise, visualization from neo4j was a plus.</p>

<p>What you sketch out on a whiteboard can be directly translated into neo4j. This was one of the best points of it.</p>

<h2>The recommendation algorithm</h2>

<p>I was particularly interested in the collaboration-filtering algorithm that Amazon used. It turns out that there are numerous ways to implement one and even combine it with a content-filtering one. I did a lot of research on machine learning and how one could transform categorical values into something comparable. This is usually done using the <strong>Pearson-correlation coefficient or cosine coefficient</strong>. After converting categorical values and representing thema s a vector, you do some linear algebra (grabbing the magnitudes) and then can transform it into a statistical value. Aftewards, one applies the k-nearest-neighbors algorithm to the two things you want to compare and you can get a list of recommended results that way.</p>

<p>I managed to implement a similarity value calculator between two different users, but for the sake of the project and simplifying it, I decided to work on the k-nearest-neighbors algorithm later. It was best to black-box the algorithm and work on the overall microservice structure first as that was the goal (dealing with optimization of queries). I definitely plan on revisiting machine learning later on (super interesting).</p>

<h2>Data generation of 40million</h2>

<p>I created a data generation script. Some of the problems I ran into were creating millions of data which was solved by generating data in batches of CSV files (JSON could have worked as well). Inserting data was done the same way.</p>

<p>A total of 10 million users, 3000 top trending product nodes were created.</p>

<p>A total of 50 million relationship types (click, wishlist, view, purchased, car) were created.</p>

<h2>Testing endpoints.</h2>

<p>Eventually I ended up implementing &lsquo;fake endpoints&rsquo; to the other services. I used my fake data to help test these results. One thing I noticed was the long query time (314ms) to return a recommended item list. I wanted to go for a much more faster, realistic speed especially when it comes to serving up millions of users at once. I wanted to aim for something below 200ms.</p>

<p>I looked up optimization methods and a couple of big words popped out:</p>

<p><strong>load balancing, horizontal/vertical scaling, sharding, caching, message bus (queues)</strong></p>

<p>In order to speed up the query time, I decided to use Redis a key-value caching database. By caching values, it optimized lookups on the most popular items to be pretty much instantaneous. The results of using redis vs not using it was night and day.</p>

<p>The end result was a 100x faster querying system going from 300ms -> 3ms.</p>

<p>The idea was to create a system where in the background at night the microservice would periodically update the cache for the most popular users. If the site was serving up someone who didn&rsquo;t come often, it&rsquo;d return a recommended list after calculations.</p>

<p><img src="https://puu.sh/zg611/931730d3d1.png" alt="stress test results" /></p>

<p>My benchmark query was 1ms. RPS: 1800~
An average query to receive some info about a user was 12ms. RPS: 1300~
An average query to receive some info about a product was 9ms. RPS: 1800~
An average query to recommend a new product was about 350ms. RPS: 44~
An average query to recommend a new product CACHED was about 6ms. RPS: 2300~</p>

<hr />

<p>An interesting thing that eventually came up was how to deploy a microservice like this to the &lsquo;real world&rsquo;.</p>

<p>One of the most popular methods was to use AWS EC2 and Docker in conjunction. A lot of research was done into this and a lot of cool things were learned. This was probably my favorite (and slightly painful) part of the project.</p>

<p>Basically you could use EC2 as a cloud computer along with Docker as a vm in order to spin up multiple instances of a certain app. It could be a db, or even my api app I created. The ability to create multiple same instances meant one could load balance. If you create multiple dbs, you could potentially shard data. All of this fell under the category of horizontally scaling ~ spreading out the work done over many instances.</p>

<p>AWS and docker was tricky to learn at first, but eventually I learned it and got my app to deploy.</p>

<h2>Below is a list of randomized notes I took while doing the project</h2>

<p>Using Redis:</p>

<p>Some questions I asked myself while thinking about and hearing about redis are&hellip;</p>

<p>What is the point of Redis?</p>

<p>What is caching?</p>

<p>What does it mean to store it in memory?</p>

<p>What makes it so much faster than storing it in a MYSQL or NOSQL database?</p>

<p>What are the tradeoffs of storing it in cache?</p>

<p>How does it work?</p>

<p>How can I use it properly?</p>

<p>How can I optimize it even more?</p>

<p>As you increase database size, so does your memory size.
<strong>useful commands</strong></p>

<pre><code>redis-server
</code></pre>

<pre><code>redis-cli
</code></pre>

<pre><code>FLUSHDB
</code></pre>

<p>Using Neo4J:</p>

<pre><code>$ neo4j-client -u neo4j localhost
</code></pre>

<p>localhost:7474</p>

<p>important queries:</p>

<p>&ldquo; FOR GETTING ALL RELATIONSHIPS &rdquo;</p>

<pre><code>MATCH (a:USER)-[relatedTo]-(b) RETURN a.name, b.name, Type(relatedTo), relatedTo;
</code></pre>

<p>&ldquo; FOR GETTING RECOMMENDED LIST FOR A SPECIFIC USER ID BASED ON WHAT OTHER USERS HAVE PURCHASED.
<code>
"MATCH (a:USER {user_id:''})-[:RELATION]-&gt;(m)&lt;-[:RELATION]-(product),(product)-[:RELATION]-&gt;(m2) RETURN m2.name AS Recommended, count(*) AS Strength ORDER BY Strength DESC LIMIT 5;
</code></p>

<pre><code>CREATE INDEX ON :Label(name);
</code></pre>

<pre><code>USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS FROM "file:///events1.csv" as input
MATCH (user:USER  {user_id: input.user_id}), (product:PRODUCT {product_id: input.product_id})
CREATE (user)-[:RELATION { type: input.event_type }]-&gt;(product);
</code></pre>

<pre><code>MATCH (n:Label {name: 'Kadin Mitchell'}),
(n)-[rel:RELATION]-&gt;(follower)
where rel.type = 'click'
return n, follower;
</code></pre>

<pre><code>MATCH (:USER {name: 'Kadin Mitchell'})-[r]-()
RETURN r
</code></pre>

<pre><code>MATCH (n:Label {name: 'b'}),
(n)-[rel:RELATION]-&gt;(follower)
where rel.type = 'FOLLOWS'
return n, follower
</code></pre>

<p>Dokku
EC2
Docker
MOCHA CHAI HTTP REQUESTS (TESTS)</p>

<p>feb 1:
<a href="https://gist.github.com/austinshin/7883fe17f990fbd69425ba7fe0e2e525">https://gist.github.com/austinshin/7883fe17f990fbd69425ba7fe0e2e525</a>
-read up on ec2/aws
-docker
-set up endpoints
-set up integration between redis (caching) and neo4j
-indexing and constraints (understand what it does in neo4j)</p>

<p>things to work on:
- set up redis fetch fake request
- do a siege test on each of the endpoints.</p>

<h2>- upload to docker and try to optimize.</h2>

<p>If our client is requesting something for live time data do we need to have a SQS / message bus system set up to handle it one by one?
my guess is no!</p>

<p>QUERY SYSTEM DATA WITH ONLY DATABASE:
<a href="https://puu.sh/zfpbl/066bf7d7cb.png">https://puu.sh/zfpbl/066bf7d7cb.png</a>
need to add &ldquo;write to product&rdquo; and &ldquo;write to user&rdquo;?
 and &ldquo;create a relationship?&rdquo;
 can these just be the same thigns over and over again so we can delete it ?</p>

<p>made sure to test incrementally
to make sure everything works</p>

<p>store in redis as {user_id: recommendedList}?
or&hellip; store as index = user_id : recommendedList?</p>

<p>takes about 5 seconds to query and cache 10 results
takes about 12 seconds to query and cache 100 reuslts
takes about 30 seconds to query and cache 1000 results</p>

<p>takes 3ms to query cached recommendations.
takes 300ms to query neo4j to calculate a recommendation.</p>

<p><a href="https://puu.sh/zg611/931730d3d1.png">https://puu.sh/zg611/931730d3d1.png</a></p>

<p>TODO:
1. change content filter method to compare to products.
2. change redis key:value schema (to be {user_id: [recommended list]})
3. add a cronjob to update every so often&hellip;
4. add logic to &ldquo;check if user/product exists. if they don&rsquo;t, MERGE them into neo4j, create a relationship&rdquo; (use a queue system or something to do this? not sure&hellip;)
^ should be able to handle a good amount of new users.
5. start working on docker and getting that set up.</p>

<p>Feb 5:
refactored redis to use hash table instead of arrays~ because I needed to keep track of userid
added mocha and chai testing for TDD (there&rsquo;s a nice article about BDD, unit tests, and TDD)
created video for thesis midpoint project
<a href="https://joshldavis.com/2013/05/27/difference-between-tdd-and-bdd/">https://joshldavis.com/2013/05/27/difference-between-tdd-and-bdd/</a></p>

<p>tomorrow&rsquo;s goals:
new relic
docker
cronjob endpoints to other two services.
read up on 10k rps&hellip;
set up a messagebus queue if i need it?
unit test endpoints</p>

<p>deployment to EC2</p>

<p>work on collaborative recommendation algorithm</p>

<hr />

<p>ec2 related stuff:
<a href="https://medium.com/@andrewcbass/install-redis-v3-2-on-aws-ec2-instance-93259d40a3ce">https://medium.com/@andrewcbass/install-redis-v3-2-on-aws-ec2-instance-93259d40a3ce</a>
ssh -i ~/.ssh/redis.pem ec2-user</p>

<p>docker stuff</p>

<ol>
<li>make a dockerfile</li>
<li>add all the commands</li>
<li>docker build -t austinshin/recservice .</li>
<li>docker run -d -p 49160:3000 -v $(pwd):/src/app &ndash;name thesis austinshin/recservice</li>
<li>to remove&hellip;</li>
<li>stop the docker container</li>
<li>docker rm containername</li>
<li>docker rmi imagename
CALL dbms.changePassword(&lsquo;123&rsquo;);</li>
</ol>


<p>docker exec -t -i container_name /bin/bash</p>

<p>docker-machine ls
docker-machine start</p>

<p>docker exec -t -i recommendationservice_neo4j_1 /bin/bash
eval &ldquo;$(docker-machine env default)&rdquo;</p>

<hr />

<p>set up queue and then have it point to multiple databases.</p>

<pre><code>ecs-cli up
ecs-cli up --keypair app --capability-iam --size 3 --instance-type t2.medium --force
ecs-cli compose --file docker-compose.yml up
change security group to allow TCP 22 (with ur ip so you can ssh in)

ssh -i ~/desktop/app.pem ec2-user@54.215.227.138
sudo yum update
sudo yum install -y docker
sudo service docker start
sudo usermod -a -G docker ec2-user
docker info
ecs-cli down
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Aircasa - A housing marketplace web app]]></title>
    <link href="http://austinshin.github.io/blog/2018/01/22/legacy/"/>
    <updated>2018-01-22T10:23:26-08:00</updated>
    <id>http://austinshin.github.io/blog/2018/01/22/legacy</id>
    <content type="html"><![CDATA[<h4>Demo</h4>

<p><a href="http://aircasa.herokuapp.com/">Try Aircasa</a></p>

<p><a href="https://github.com/hrsf87-casa/aircasa">Github</a></p>

<h5>Summary</h5>

<ul>
<li>Adopted a Minimal Viable Product of a <a href="https://github.com/airbnb-clone/airbnb">Airbnb clone</a> from a group of people who worked on it previously hence the name &lsquo;Legacy&rsquo;.</li>
<li>Familiarized self with a new code base, refactored code, added multiple new features, and deployed to heroku.</li>
</ul>


<!-- more -->


<h4>Stack</h4>

<ul>
<li>React</li>
<li>Express</li>
<li>MYSQL

<h5>Features Added</h5></li>
<li>PassportJS/Bcrypt (Login Authentication)</li>
<li>Ability to host a place</li>
<li>Track current and past bookings</li>
<li>Unique profile page</li>
<li>Uploading files utilizing Amazon Web Services</li>
<li>Fetch live data via Airbnb API</li>
<li>Styling via Bootstrap and CSS Grid</li>
<li>Provide map data via Google Maps API</li>
</ul>


<h2>The Project Phase</h2>

<p>Interesting decisions/challenges encountered.
1. Adopting a new codebase, modularity, documentation, and refactoring.
2. Learning a new technology/Methods of research
3. CSS Styling</p>

<p>This was my first time adopting a sizable codebase. Some of the things I asked myself as I was going through were
- What does this application aim to achieve? - <strong>Purpose</strong>
- How can I get this application to work so I can test its features? - <strong>Stability</strong>
- What potential features can I add to make this app stellar? - <strong>Future</strong></p>

<h5><em><strong>Modularity and Refactoring</strong></em></h5>

<p>As I was reading through it the first time, I realized the importance of documentation as well as modularity. Most of the code that should have been split up into many different files were placed in one file making it confusing and hard to understand what was going on. Functions names were out of place, styling was incorrect, and it made a lot of components that should have been simple to understand complex.</p>

<p>I always aim to code in a way that if I were to read my code 1 year from now I&rsquo;d be able to understand it. Doing so should allow others to understand it as well. So the first goal of the project immediately was to figure out what each components did, figure out why the application wasn&rsquo;t working as intended (because it was riddled with bugs), and <strong>refactor the code</strong>.</p>

<p>My teammates and I went through each file carefully dissecting which pieces were unneeded and what was needed. The first day was spent documenting and understanding how everything worked and fell in place. Afterwards, we worked to create a working application where all we had to do afterwards was to add features individually.</p>

<h5><em><strong>As a user I&rsquo;d like to be able to have a profile page that has information about me.</strong></em></h5>

<p>As the project went on I found myself working on user-facing features. The perspective of the the user was always a conscious thought. By coding in such a manner I found myself thinking about what a user would like which led to more and more features that would be nice to have (in other words, improve the user experience). Being a user of many websites myself, it was easy to think about what turns me off and makes me exit a website instantly.</p>

<p>Rather than overwhelming myself with all these &ldquo;neat features&rdquo; to include immediately, I incrementally added each nice feature to a ticketing system. Then, I worked on each one by one, keeping things modular, testing each feature as I progressed, and making sure it was just the way a user would like it. After a day&rsquo;s work, I reconvened with my team members to make sure the vision of the project was still intact. I also discussed with them if there were any other demanding features that came up that should be implemented first. <strong>Communication</strong> is key in making a project succeed. This was how most of the project was carried out afterwards.</p>

<h5><em><strong>CSS Styling</strong></em></h5>

<p>I found my biggest struggle in the project with the CSS. I&rsquo;ve previously read how arcane CSS is. I&rsquo;ve worked with template CSS bit by bit before, but this was the first time I was working from a true blank page. It was my first experience with creating a modular layout in which features can be implemented bit by bit while add styles. I&rsquo;ve used bootstrap before when working with small pieces. This time though, I wanted to undertake a bigger challenge and decided to learn the new CSS Grid system. It could have gone better, but I learned a fair amount about some of the limitations as well as the magic of CSS.</p>

<p>One of the most most important things I&rsquo;ve learned is <strong>try to plan as much of the layout as possible early.</strong>
Also, <strong>don&rsquo;t hardcode pixels. Use % and vw/vh.</strong>
One more thing, <strong>making a site with CSS from scratch is hard and takes practice.</strong> But it was fun!</p>

<h3>Wrap Up</h3>

<ul>
<li>Modularity, code documentation, proper styling leads to less confusion</li>
<li>This means when working with other or new teammembers it makes it easier on them to implement new features.</li>
<li>Fewer bugs this way too!</li>
<li>Importance of UI design (style) nearly matches functionality.</li>
<li>If it looks ugly, why would I use it even if it is functional?</li>
<li>Think from the perspective of a user always! What does the user want?</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Slackcasa - chatting web app]]></title>
    <link href="http://austinshin.github.io/blog/2018/01/22/greenfield/"/>
    <updated>2018-01-22T10:23:16-08:00</updated>
    <id>http://austinshin.github.io/blog/2018/01/22/greenfield</id>
    <content type="html"><![CDATA[<h4>Demo</h4>

<p><a href="https://slackk-casa.herokuapp.com/">Try Slackcasa</a></p>

<p><a href="https://github.com/austinshin/slackk-casa">Github</a></p>

<h5>Summary</h5>

<ul>
<li>Created a full stack web application clone from scratch of <a href="https://slack.com/">Slack</a>.</li>
<li>Worked with Trello (ticketing system), 3 other team members and implemented features for one week.</li>
</ul>


<!-- more -->


<h4>Stack</h4>

<ul>
<li>React</li>
<li>Express</li>
<li>PostGreSQL

<h5>Features Added</h5></li>
<li>Login Authentication via PassportJS</li>
<li>Passport Encryption via Bcrypt</li>
<li>Route handling via React-Router</li>
<li>Realtime Live Chat system between clients via Native JS Websockets</li>
<li>E-mail notifications via Nodemailer and CronJob</li>
<li>Unique workspaces (chatrooms) for users to join/chat</li>
<li>Styling done via Bootstrap</li>
</ul>


<h2>The Project Phase</h2>

<p>Interesting decisions/challenges encountered.
1. Creation of a web application with skills learned from before for the first time.
2. Working as a group to create a vision for the application and working to make that vision come true.
3. Creating a ticketing system.
4. Modularizing and documenting code.
5. Git Workflow
6. Websockets, Postgres, Passport</p>

<p>This was my first time working with multiple team members to create a project.
The application goal was to create an interactive, seamless, lagless environment with users connecting and chatting to each other.
My goal was to practice communicating effectively, create a modular codebase such that other members could implement features without running into merge conflicts, and learn new technologies.</p>

<h5><strong>Planning Phase</strong></h5>

<p>My team members and I spent the entire first day talking about the project. I proposed the idea we try to plan as much as possible so that we have a good sense of the big picture. By creating a vision it helps when thinking about features to implement. You can then ask yourself, does this feature work towards the vision? If not, do we need to reconvene and reevaluate our vision? From past experience, having an end goal helps keep people focused and not lose their sense of direction.</p>

<p>By the end of the day, we had multiple features to implement ticketed in the perspective of a user. <strong>As a user I&rsquo;d like to have this feature&hellip;</strong> i.e. As a user I&rsquo;d like to be able to login. This obviously led to multiple features added on top of that, but having everything written out and ticketed allows for anyone to pick up the &lsquo;ticket&rsquo; and start working towards it. Also, by separating everything out and planning most of it meant it was easy to keep things documented and modular.</p>

<p>Topics like
- &lsquo;What is our schema for pgsql going to look like?&rsquo;.
- &lsquo;What are our variables name going to be?&rsquo;
- &lsquo;What form is our data going to be sent in when communicating with the front end and back end?&rsquo;</p>

<p>We took many pictures and uploaded them for easy viewing and later reference.
It was in a sense exhausting, but felt well worth it. Everyone felt on the same page which is super key in group projects.</p>

<h4>_<strong>Implementation</strong>__</h4>

<p>It turned out that some of these technologies we were working on were new to everyone. Since everyone wanted to learn and we had four people, it made sense to do some pair programming. Adopting the driver-navigator system we proceeded to split up the work on front end and database/back end. We switched around partners to learn about websockets and how they worked on both the front and back end.</p>

<h4>_<strong>Websockets</strong>__</h4>

<p>Websockets are really cool. I&rsquo;ve worked on a chat system before but that was using native RESTFUL API where messages were updated via a setInterval. Now with websockets, everything was going to be realtime. It solves the problem of browsers being able to communicate to servers and servers to other browsers what seems to be instantly. This bi directional connection was the key to making our chat system work so it was naturally very important we implement it properly and in a way where we can reuse it when we need to implement other features.</p>

<p>We chose native websockets over sockets.io to get a better understanding of how websockets work.</p>

<h4>_<strong>PostgreSQL</strong>__</h4>

<p>Why postgres over MongoDB or MYSQL? Well, it made sense to use an ORM, but also a database in which you can join tables because of the nature of our project&rsquo;s schema. I already knew how to use MYSQL so I wanted to undertake a challenge of learning something new. The answer was PostgreSQL. It was fairly easy to pick up and intuitive to use. It shared many similarities as MYSQL (unsurprisingly).</p>

<p>As the mvp fell into place, my team members and I started to split off and work on separate features. I wanted to work on a notification system in which text and email notifications would be sent. I realized while I was planning it how much depth there would be when creating such a system. Having one type of notification system is hard enough, but add two? That&rsquo;s another layer of complexity. Then I thought about, what if you want to turn off notifications&hellip; or what if you wanted only specific notifications. I didn&rsquo;t have much time left, so I worked on what I could. Twilio or bandwidth is good to use for text notifications and I worked on it in the past. I decided to use nodemailer to send e-mail notifications and played around with cronjob to filter out certain emails and send them on a interval. It was cool (and spammy)!</p>

<h3>Wrap Up</h3>

<ul>
<li>I learned a huge deal about planning and how long it could take. The project was seemingly small, but it took a whole day. I wonder what it&rsquo;d be like in a big company with a big app.</li>
<li>Keeping things modular allows you to keep to problem small, while maintaing a vision. It means you can implement new features separately without breaking the function of the app.</li>
<li>Documentation is key because it means your team members can read and understand the code. This also means good code styling and function names.</li>
<li>As a result of point 3, our project was picked the most by others in our class to reuse for their next project.</li>
<li>Learning new technologies is always fun, and I was surprised at how good I&rsquo;ve gotten at it. I&rsquo;m aiming to get faster and better at it.</li>
</ul>

]]></content>
  </entry>
  
</feed>
